# High-Level Architecture & Data Model

## 1. Node Data Model (JSON)

Each node in the workflow represents a step in the process. The state of a node is defined by its configuration (the 3 tabs) and its execution context (inputs/outputs).

```json
{
  "id": "node-1",
  "type": "customNode",
  "position": { "x": 100, "y": 100 },
  "data": {
    "label": "Process Data",
    "status": "idle", // idle, running, success, error
    "config": {
      "naturalLanguage": "Read the CSV file and filter for rows where age > 30.",
      "pseudocode": "1. Open input file\n2. Parse CSV\n3. Filter rows\n4. Save to output file",
      "pythonScript": "import pandas as pd\n\ndef run(input_path, output_path):\n    df = pd.read_csv(input_path)\n    filtered = df[df['age'] > 30]\n    filtered.to_csv(output_path, index=False)"
    },
    "io": {
      "inputPath": "/tmp/workflow/node-0/output.csv", // Populated from previous node
      "outputPath": "/tmp/workflow/node-1/output.csv"  // Generated by this node
    }
  }
}
```

## 2. API Endpoint Strategy

The backend is a lightweight runner. It does not manage complex state persistence (that's handled by the frontend or a project file), but it handles the execution of individual nodes.

### `POST /execute-node`

Executes a single node's script.

**Request Body:**
```json
{
  "nodeId": "node-1",
  "script": "import pandas as pd...", 
  "inputPath": "/path/to/input/file.csv",
  "outputPath": "/path/to/output/file.csv"
}
```

**Response:**
```json
{
  "status": "success", // or "error"
  "logs": "Processed 500 rows...",
  "error": null
}
```

### `GET /health`
Simple check to ensure the local runner is active.
